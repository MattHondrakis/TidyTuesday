---
title: "Weather Forcasts"
author: "Matthew"
date: "2022-12-20"
output: 
  github_document:
    toc: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, dpi = 500)
library(tidyverse)
library(scales)
library(patchwork)
library(tidymodels)
library(lubridate)
library(astsa)
library(forecast)
theme_set(theme_bw())
theme_update(plot.title = element_text(hjust = 0.5))
```

```{r include=FALSE}
weather_forecasts <- read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-12-20/weather_forecasts.csv')
cities <- read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-12-20/cities.csv')
outlook_meanings <- read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-12-20/outlook_meanings.csv')
```

# Data Cleaning

```{r}
weather_forecasts <- weather_forecasts %>% 
  left_join(outlook_meanings)  
```

The *weather forecasts* dataset contains abbreviated weather outlooks, while the *outlook meanings* dataset contains non-abbreviated weather outlooks. The *weather forecasts* dataset and the *outlook meanings* dataset were joined together using the "forecast_outlook" column as a common key. This resulted in a combined dataset that includes both the abbreviated and non-abbreviated weather outlooks from the two datasets.

```{r}
weather_forecasts %>% 
  count(meaning, sort = TRUE)
```

## Data View

```{r}
weather_forecasts %>% 
  head(n = 10) %>% 
  knitr::kable()
```

## Missing Values

```{r}
skimr::skim(weather_forecasts) %>% select(skim_type, skim_variable, n_missing)
```

```{r}
weather_forecasts %>% 
  group_by(NA_meaning = is.na(meaning)) %>% 
  summarize(sum(is.na(forecast_temp)))

weather_forecasts %>% 
  group_by(forecast_hours_before) %>% 
  summarize(sum(is.na(forecast_temp)))
```

```{r}
weather_forecasts %>% 
  group_by(forecast_hours_before) %>% 
  summarize(sum(is.na(forecast_temp)))
```

Missing values for *forecast_temp* tend to appear where forecast *meaning* is also NA. They also slightly increase as the number of hours before. It is assumed that these missing values are due to there being no forecast at that time. Thus, these rows will not be dropped.

## Outliers

```{r}
weather_forecasts %>% 
  count(possible_error, sort = TRUE)
```

```{r}
weather_forecasts %>% 
  filter(possible_error == "observed_temp") %>% 
  select(contains("temp"))
weather_forecasts %>% 
  filter(possible_error == "forecast_temp") %>% 
  select(contains("temp"))
```

Column *possible_error* appears to show what **potentially** is flawed in that row, instead of inconsistancies between the forecast and observed. For instance, when *possible_error* equals "forecast_temp", all values for *forecast_temp* are **-10** and when it equals "observed_temp", values are either **0** or **108**.

# Exploratory Data Analysis

## Temperature Difference

```{r}
weather_forecasts <- weather_forecasts %>% 
  mutate(diff_temp = observed_temp - forecast_temp,
         prop_difftemp = diff_temp/observed_temp) 
```

Column of *temperature differences* and *proportional temperature differences* created above.

### States

```{r}
weather_forecasts %>% 
  filter(possible_error == "none") %>% 
  group_by(state) %>% 
  summarize(avg_diff = mean(abs(diff_temp), na.rm = TRUE)) %>% 
  slice_max(avg_diff, n = 10) %>% 
  ggplot(aes(avg_diff, fct_reorder(state, avg_diff), fill = avg_diff)) +
  geom_col(color = "black") + 
  scale_fill_viridis_c() +
  labs(x = "Average Forecast Temperature Error", y = "", 
       title = "Top 10 States with Highest Average Prediction Error") +
  theme(legend.position = "none")

```

```{r}
# Select top 6 states without highest average error
top6states <- weather_forecasts %>% 
  filter(possible_error == "none") %>% 
  group_by(state) %>% 
  summarize(avg_diff = mean(abs(diff_temp), na.rm = TRUE)) %>% 
  slice_max(abs(avg_diff), n = 6) %>% 
  pull(state)
```

```{r}
(weather_forecasts %>% 
  filter(state %in% top6states & possible_error == "none") %>% 
  ggplot(aes(date, diff_temp, color = state)) +
  geom_line() + theme(legend.position = "none") +
  labs(title = "Temperature Difference", x = "", y = "") +
  facet_wrap(~state, scales = "free")) /
(weather_forecasts %>% 
  filter(state %in% top6states & possible_error == "none") %>% 
  ggplot(aes(date, prop_difftemp, color = state)) + 
  geom_line() + theme(legend.position = "none") +
  labs(title = "Proportional Temperature Difference", x = "", y = "") +
  facet_wrap(~state, scales = "free"))
```

#### New York

```{r}
ny_weather <- weather_forecasts %>% 
  filter(state == "NY")
```

```{r}
ny_weather %>% 
  ggplot(aes(date, prop_difftemp)) +
  geom_line()
```

```{r}
ny_weather %>% 
  filter(prop_difftemp != -Inf) %>% 
  filter(abs(prop_difftemp) > 2.5) %>% 
  arrange(-abs(prop_difftemp)) %>% select(prop_difftemp)
```

# Time Series

Only keeping data within New York City, and since there are multiple values for each day, only the average will be kept.

```{r}
nycseries <- ny_weather %>% 
  filter(city == "NEW_YORK_CITY") %>% 
  distinct(date,observed_temp) %>% 
  group_by(date) %>% 
  summarize(observed_temp = mean(observed_temp, na.rm = TRUE)) %>% 
  arrange(date) %>% 
  drop_na()
```

## NYC Temperature

```{r}
(nycseries %>% 
  ggplot(aes(date, observed_temp)) +
  geom_line() +
  labs(y = "", x = "", title = "Observed Temperature")) /
(nycseries %>% 
  mutate(diff_temp = c(mean(nycseries$observed_temp, na.rm = TRUE), 
                       diff(observed_temp))) %>% 
  slice(-1) %>% 
  ggplot(aes(date, diff_temp)) +
  geom_line() +
  labs(y = "", x = "", title = "Differenced Temperature"))
```

## ARIMA Model

```{r}
nyctz <- ts(nycseries$observed_temp, start = c(2021,01,30), frequency = 365)
```

```{r}
sarima(nyctz, 1,1,3)
```

```{r}
sarima.for(nyctz, 10, 1,1,3)
```
